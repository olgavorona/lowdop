---
status: planned
depends_on: [1, 2]
wave: 2
skills: [code-writing]
verify: bash
reviewers: [code-reviewer, test-reviewer]
teammate_name:
---

# Task 4: Labyrinth model + StoryInfo + LabyrinthLoader

## Required Skills

Before executing, load:
- `/skill:code-writing` — [skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Add the `StoryInfo` model that the bookshelf screen (Task 8) will consume. Extend the `Labyrinth` model with computed properties for story number and level name. Extend `LabyrinthLoader` with story-based loading methods. Update `loadForDifficulty()` to work with the new difficulty names (easy/medium/hard) produced by Tasks 1 and 2.

This task bridges the data layer between the content file changes (Task 1) and the new manifest structure, and the difficulty enum reduction (Task 2). Downstream tasks (BookshelfView, GameViewModel, LabyrinthGridView) all depend on the models and loading methods created here.

## What to do

1. **Add `StoryInfo` model** to `Labyrinth.swift` (same file, below the existing models):
   - `struct StoryInfo: Identifiable` with properties: `number`, `title`, `location`, `characterEnd`, `isFree`, `isAdventure`, `labyrinthIds`
   - `var id: Int { number }`

2. **Update `LabyrinthManifest`** to decode the new manifest structure produced by Task 1:
   - Add `packs: [PackInfo]` field (the new manifest wraps stories inside packs)
   - Add `PackInfo` struct: `id: String`, `title: String`, `free_stories: Int`, `stories: [Int]`
   - Keep `labyrinths: [ManifestEntry]` for backward compatibility (the flat labyrinth list remains in the manifest)

3. **Add `story` field to `ManifestEntry`** (Task 1 adds `"story": N` to each manifest entry)

4. **Add computed properties to `Labyrinth`**:
   - `storyNumber: Int` — parse from ID: `"denny_001_easy"` -> `1`. Extract the 3-digit segment after the first underscore, convert to Int.
   - `levelName: String` — parse from ID: `"denny_001_easy"` -> `"easy"`. Extract the segment after the last underscore. This should match the `difficulty` field but is derived from the ID for robustness.

5. **Add `loadStories()` to `LabyrinthLoader`**:
   - Parse `manifest.json` `packs[0].stories` array of story numbers
   - For each story number, gather metadata from the matching `ManifestEntry` items (same story number, any difficulty)
   - Determine `characterEnd` from the first matching labyrinth's `characterEnd.imageAsset` (load one JSON to get character data, or derive from manifest if available)
   - Set `isFree = storyNumber <= freeStories` (from `packs[0].free_stories`)
   - Set `isAdventure = storyNumber >= 11` (stories 11-20 have collectible items)
   - Collect labyrinth IDs for each story: all entries where `story == storyNumber`
   - Return `[StoryInfo]` sorted by story number

6. **Add `loadForStory(storyNumber:difficulty:)` to `LabyrinthLoader`**:
   - Load the single labyrinth matching both story number and difficulty
   - Return `Labyrinth?`

7. **Add `loadAllForStory(storyNumber:)` to `LabyrinthLoader`**:
   - Load all 3 difficulty variants for one story (easy, medium, hard)
   - Return `[Labyrinth]` sorted by difficulty order (easy first, hard last)

8. **Update `loadForDifficulty()`**:
   - After Task 2, `DifficultyLevel.rawValue` produces "easy"/"medium"/"hard"
   - After Task 1, JSON files have `difficulty: "easy"/"medium"/"hard"`
   - The filter `$0.difficulty == level.rawValue` should continue to work, but verify the interleave logic still makes sense with 20 stories per difficulty (instead of 10 normal + 10 adventure = 20 total)

9. **Invalidate cache** when needed: `loadStories()` can use the same `loadAll()` cache since it reads from the same manifest data.

## TDD Anchor

Write these tests BEFORE implementing the production code. Run them, confirm they fail, then implement.

- `LowDopamineLabyrinthTests/StoryInfoTests.swift::testStoryInfoCreation` — Create a `StoryInfo` with number=1, verify `id == 1`, `isFree == true`
- `LowDopamineLabyrinthTests/StoryInfoTests.swift::testStoryInfoFreeStatus` — Stories 1-3 have `isFree == true`, story 4 has `isFree == false`
- `LowDopamineLabyrinthTests/StoryInfoTests.swift::testStoryInfoAdventureStatus` — Stories 1-10 have `isAdventure == false`, stories 11-20 have `isAdventure == true`
- `LowDopamineLabyrinthTests/LabyrinthModelTests.swift::testStoryNumberParsedFromId` — `Labyrinth` with `id: "denny_005_easy"` has `storyNumber == 5`
- `LowDopamineLabyrinthTests/LabyrinthModelTests.swift::testLevelNameParsedFromId` — `Labyrinth` with `id: "denny_005_easy"` has `levelName == "easy"`
- `LowDopamineLabyrinthTests/LabyrinthModelTests.swift::testStoryNumberFromVariousIds` — Test parsing from `"denny_001_easy"`, `"denny_020_hard"`, `"denny_010_medium"`

Note: `loadStories()`, `loadForStory()`, and `loadAllForStory()` depend on Bundle resources which are difficult to unit test in isolation. Testing these methods is deferred to Task 11 (integration tests) or verified via the build + manual check. The model-level computed properties and `StoryInfo` struct are the primary TDD targets here.

## Acceptance Criteria

- [ ] `StoryInfo` struct exists in `Labyrinth.swift` with all required fields (number, title, location, characterEnd, isFree, isAdventure, labyrinthIds)
- [ ] `StoryInfo` conforms to `Identifiable` with `var id: Int { number }`
- [ ] `LabyrinthManifest` can decode the new pack-based manifest structure (packs array with stories)
- [ ] `ManifestEntry` has a `story: Int` field
- [ ] `Labyrinth` has `storyNumber: Int` computed property that correctly parses the story number from the ID
- [ ] `Labyrinth` has `levelName: String` computed property that correctly parses the difficulty suffix from the ID
- [ ] `LabyrinthLoader.loadStories()` exists and returns `[StoryInfo]`
- [ ] `LabyrinthLoader.loadForStory(storyNumber:difficulty:)` exists and returns `Labyrinth?`
- [ ] `LabyrinthLoader.loadAllForStory(storyNumber:)` exists and returns `[Labyrinth]`
- [ ] `loadForDifficulty()` continues to work with the new 3-level difficulty values
- [ ] `xcodebuild build` succeeds
- [ ] Unit tests for `StoryInfo` and `Labyrinth` computed properties pass

## Context Files

- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)
- [code-research.md](../code-research.md)
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Models/Labyrinth.swift` — model file to modify
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Services/LabyrinthLoader.swift` — loader to extend
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Resources/Labyrinths/manifest.json` — after Task 1 transforms it to pack structure
- `LowDopamineLabyrinth/LowDopamineLabyrinth/ViewModels/GameViewModel.swift` — primary consumer of LabyrinthLoader
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Models/UserPreferences.swift` — DifficultyLevel enum (modified by Task 2)
- `LowDopamineLabyrinth/LowDopamineLabyrinthTests/GameViewModelTests.swift` — existing test patterns

## Verification Steps

- Step 1: Run `xcodebuild build` — expect BUILD SUCCEEDED
- Step 2: Run `xcodebuild test -only-testing:LowDopamineLabyrinthTests` — expect all tests pass (including new StoryInfo and Labyrinth computed property tests)
- Step 3: Grep for `StoryInfo` in `Labyrinth.swift` — should exist
- Step 4: Grep for `loadStories` in `LabyrinthLoader.swift` — should exist
- Step 5: Grep for `storyNumber` in `Labyrinth.swift` — should exist as computed property
- Step 6: Grep for `loadForStory` in `LabyrinthLoader.swift` — should exist

## Details

**Files to modify:**
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Models/Labyrinth.swift` — add `StoryInfo`, `PackInfo`, computed properties on `Labyrinth`, update `LabyrinthManifest` and `ManifestEntry`
- `LowDopamineLabyrinth/LowDopamineLabyrinth/Services/LabyrinthLoader.swift` — add `loadStories()`, `loadForStory()`, `loadAllForStory()`

**New test file:**
- `LowDopamineLabyrinth/LowDopamineLabyrinthTests/StoryInfoTests.swift` — or add to existing test file; tests for StoryInfo and Labyrinth computed properties

**Dependencies:**
- Task 1 (content files): manifest.json must have the new pack structure with `packs` array and `story` field on each labyrinth entry
- Task 2 (DifficultyLevel): enum must be reduced to 3 cases (easy/medium/hard) before `loadForDifficulty()` will match correctly

**Edge cases:**
- ID parsing: handle IDs that don't follow the `denny_NNN_difficulty` pattern gracefully (return 0 for storyNumber, empty string for levelName)
- Empty manifest: `loadStories()` should return `[]` if manifest cannot be loaded
- Missing labyrinth file: `loadForStory()` returns `nil` if the JSON file is missing from the bundle
- Difficulty ordering in `loadAllForStory()`: must return easy, medium, hard in that order (not alphabetical, which would be easy, hard, medium)

**Implementation hints:**
- `storyNumber` can be parsed by splitting the ID on `_` and taking the second component: `id.split(separator: "_")[1]` then converting to Int
- `levelName` is the last component after splitting on `_`: `id.split(separator: "_").last`
- For `loadStories()`, group `ManifestEntry` items by story number, then build `StoryInfo` for each group
- `characterEnd` requires loading at least one labyrinth JSON per story (the manifest entries don't include character data). Consider loading lazily or caching.
- The `loadAllForStory` difficulty order can use a hardcoded order array: `["easy", "medium", "hard"]` and sort results by index in that array
- `PackInfo` should use `CodingKeys` with `free_stories` mapping to `freeStories`

## Reviewers

- **code-reviewer** -> `logs/working/task-4/code-reviewer-{round}.json`
- **test-reviewer** -> `logs/working/task-4/test-reviewer-{round}.json`

## Post-completion

- [ ] Record brief report in decisions.md (Summary: 1-3 sentences, review references with JSON links, no findings tables or dumps)
- [ ] If deviated from spec — describe deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
